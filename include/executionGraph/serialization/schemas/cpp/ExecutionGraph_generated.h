// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

#include "executionGraph/serialization/schemas/cpp/DataTypes_generated.h"
#include "executionGraph/serialization/schemas/cpp/GraphTypeDescription_generated.h"
#include "executionGraph/serialization/schemas/cpp/GraphVisualization_generated.h"
#include "executionGraph/serialization/schemas/cpp/LogicNode_generated.h"
#include "executionGraph/serialization/schemas/cpp/LogicSocket_generated.h"
#include "executionGraph/serialization/schemas/cpp/NodeTypeDescription_generated.h"
#include "executionGraph/serialization/schemas/cpp/SocketLinkDescription_generated.h"
#include "executionGraph/serialization/schemas/cpp/SocketTypeDescription_generated.h"

namespace executionGraph {
namespace serialization {

struct ExecutionGraphNodeProperties;

struct ExecutionGraph;

enum NodeClassification {
  NodeClassification_NormalNode = 0,
  NodeClassification_InputNode = 1,
  NodeClassification_OutputNode = 2,
  NodeClassification_ConstantNode = 3,
  NodeClassification_MIN = NodeClassification_NormalNode,
  NodeClassification_MAX = NodeClassification_ConstantNode
};

inline const NodeClassification (&EnumValuesNodeClassification())[4] {
  static const NodeClassification values[] = {
    NodeClassification_NormalNode,
    NodeClassification_InputNode,
    NodeClassification_OutputNode,
    NodeClassification_ConstantNode
  };
  return values;
}

inline const char * const *EnumNamesNodeClassification() {
  static const char * const names[] = {
    "NormalNode",
    "InputNode",
    "OutputNode",
    "ConstantNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeClassification(NodeClassification e) {
  if (e < NodeClassification_NormalNode || e > NodeClassification_ConstantNode) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeClassification()[index];
}

struct ExecutionGraphNodeProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEID = 4,
    VT_CLASSIFICATION = 6,
    VT_GROUPS = 8
  };
  uint64_t nodeId() const {
    return GetField<uint64_t>(VT_NODEID, 0);
  }
  NodeClassification classification() const {
    return static_cast<NodeClassification>(GetField<int8_t>(VT_CLASSIFICATION, 0));
  }
  const flatbuffers::Vector<uint64_t> *groups() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_GROUPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NODEID) &&
           VerifyField<int8_t>(verifier, VT_CLASSIFICATION) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.VerifyVector(groups()) &&
           verifier.EndTable();
  }
};

struct ExecutionGraphNodePropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeId(uint64_t nodeId) {
    fbb_.AddElement<uint64_t>(ExecutionGraphNodeProperties::VT_NODEID, nodeId, 0);
  }
  void add_classification(NodeClassification classification) {
    fbb_.AddElement<int8_t>(ExecutionGraphNodeProperties::VT_CLASSIFICATION, static_cast<int8_t>(classification), 0);
  }
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups) {
    fbb_.AddOffset(ExecutionGraphNodeProperties::VT_GROUPS, groups);
  }
  explicit ExecutionGraphNodePropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutionGraphNodePropertiesBuilder &operator=(const ExecutionGraphNodePropertiesBuilder &);
  flatbuffers::Offset<ExecutionGraphNodeProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionGraphNodeProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionGraphNodeProperties> CreateExecutionGraphNodeProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nodeId = 0,
    NodeClassification classification = NodeClassification_NormalNode,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups = 0) {
  ExecutionGraphNodePropertiesBuilder builder_(_fbb);
  builder_.add_nodeId(nodeId);
  builder_.add_groups(groups);
  builder_.add_classification(classification);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionGraphNodeProperties> CreateExecutionGraphNodePropertiesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nodeId = 0,
    NodeClassification classification = NodeClassification_NormalNode,
    const std::vector<uint64_t> *groups = nullptr) {
  return executionGraph::serialization::CreateExecutionGraphNodeProperties(
      _fbb,
      nodeId,
      classification,
      groups ? _fbb.CreateVector<uint64_t>(*groups) : 0);
}

struct ExecutionGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHDESCRIPTION = 4,
    VT_NODES = 6,
    VT_LINKS = 8,
    VT_NODEPROPERTIES = 10,
    VT_VISUALIZATION = 12
  };
  const GraphTypeDescription *graphDescription() const {
    return GetPointer<const GraphTypeDescription *>(VT_GRAPHDESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LogicNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LogicNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<const SocketLinkDescription *> *links() const {
    return GetPointer<const flatbuffers::Vector<const SocketLinkDescription *> *>(VT_LINKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ExecutionGraphNodeProperties>> *nodeProperties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExecutionGraphNodeProperties>> *>(VT_NODEPROPERTIES);
  }
  const GraphVisualization *visualization() const {
    return GetPointer<const GraphVisualization *>(VT_VISUALIZATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAPHDESCRIPTION) &&
           verifier.VerifyTable(graphDescription()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(links()) &&
           VerifyOffset(verifier, VT_NODEPROPERTIES) &&
           verifier.VerifyVector(nodeProperties()) &&
           verifier.VerifyVectorOfTables(nodeProperties()) &&
           VerifyOffset(verifier, VT_VISUALIZATION) &&
           verifier.VerifyTable(visualization()) &&
           verifier.EndTable();
  }
};

struct ExecutionGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphDescription(flatbuffers::Offset<GraphTypeDescription> graphDescription) {
    fbb_.AddOffset(ExecutionGraph::VT_GRAPHDESCRIPTION, graphDescription);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogicNode>>> nodes) {
    fbb_.AddOffset(ExecutionGraph::VT_NODES, nodes);
  }
  void add_links(flatbuffers::Offset<flatbuffers::Vector<const SocketLinkDescription *>> links) {
    fbb_.AddOffset(ExecutionGraph::VT_LINKS, links);
  }
  void add_nodeProperties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExecutionGraphNodeProperties>>> nodeProperties) {
    fbb_.AddOffset(ExecutionGraph::VT_NODEPROPERTIES, nodeProperties);
  }
  void add_visualization(flatbuffers::Offset<GraphVisualization> visualization) {
    fbb_.AddOffset(ExecutionGraph::VT_VISUALIZATION, visualization);
  }
  explicit ExecutionGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutionGraphBuilder &operator=(const ExecutionGraphBuilder &);
  flatbuffers::Offset<ExecutionGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionGraph> CreateExecutionGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GraphTypeDescription> graphDescription = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogicNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SocketLinkDescription *>> links = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExecutionGraphNodeProperties>>> nodeProperties = 0,
    flatbuffers::Offset<GraphVisualization> visualization = 0) {
  ExecutionGraphBuilder builder_(_fbb);
  builder_.add_visualization(visualization);
  builder_.add_nodeProperties(nodeProperties);
  builder_.add_links(links);
  builder_.add_nodes(nodes);
  builder_.add_graphDescription(graphDescription);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionGraph> CreateExecutionGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GraphTypeDescription> graphDescription = 0,
    const std::vector<flatbuffers::Offset<LogicNode>> *nodes = nullptr,
    const std::vector<SocketLinkDescription> *links = nullptr,
    const std::vector<flatbuffers::Offset<ExecutionGraphNodeProperties>> *nodeProperties = nullptr,
    flatbuffers::Offset<GraphVisualization> visualization = 0) {
  return executionGraph::serialization::CreateExecutionGraph(
      _fbb,
      graphDescription,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<LogicNode>>(*nodes) : 0,
      links ? _fbb.CreateVectorOfStructs<SocketLinkDescription>(*links) : 0,
      nodeProperties ? _fbb.CreateVector<flatbuffers::Offset<ExecutionGraphNodeProperties>>(*nodeProperties) : 0,
      visualization);
}

inline const executionGraph::serialization::ExecutionGraph *GetExecutionGraph(const void *buf) {
  return flatbuffers::GetRoot<executionGraph::serialization::ExecutionGraph>(buf);
}

inline const executionGraph::serialization::ExecutionGraph *GetSizePrefixedExecutionGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<executionGraph::serialization::ExecutionGraph>(buf);
}

inline const char *ExecutionGraphIdentifier() {
  return "EXGR";
}

inline bool ExecutionGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ExecutionGraphIdentifier());
}

inline bool VerifyExecutionGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<executionGraph::serialization::ExecutionGraph>(ExecutionGraphIdentifier());
}

inline bool VerifySizePrefixedExecutionGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<executionGraph::serialization::ExecutionGraph>(ExecutionGraphIdentifier());
}

inline void FinishExecutionGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executionGraph::serialization::ExecutionGraph> root) {
  fbb.Finish(root, ExecutionGraphIdentifier());
}

inline void FinishSizePrefixedExecutionGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executionGraph::serialization::ExecutionGraph> root) {
  fbb.FinishSizePrefixed(root, ExecutionGraphIdentifier());
}

}  // namespace serialization
}  // namespace executionGraph

#endif  // FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_
