//! ========================================================================================
//!  ExecutionGraph
//!  Copyright (C) 2014 by Gabriel Nützi <gnuetzi (at) gmail (døt) com>
//!
//!  @date Mon Jan 08 2018
//!  @author Gabriel Nützi, <gnuetzi (at) gmail (døt) com>
//!
//!  This Source Code Form is subject to the terms of the Mozilla Public
//!  License, v. 2.0. If a copy of the MPL was not distributed with this
//!  file, You can obtain one at http://mozilla.org/MPL/2.0/.
//! ========================================================================================

#ifndef executionGraph_graphs_ExecutionTree_hpp
#define executionGraph_graphs_ExecutionTree_hpp

#include <algorithm>
#include <deque>
#include <set>
#include <unordered_set>
#include <fmt/printf.h>
#include <rttr/type>
#include "executionGraph/common/Assert.hpp"
#include "executionGraph/common/DemangleTypes.hpp"
#include "executionGraph/common/StringFormat.hpp"
#include "executionGraph/nodes/LogicCommon.hpp"
#include "executionGraph/nodes/LogicNode.hpp"
#include "executionGraph/nodes/LogicNodeDefaultPool.hpp"
#include "executionGraph/nodes/LogicSocket.hpp"

#define EXECGRAPH_EXECTREE_SOLVER_LOG(...) EXECGRAPH_DEBUG_ONLY(EXECGRAPH_LOG_TRACE(__VA_ARGS__));

namespace executionGraph
{
    /* ---------------------------------------------------------------------------------------*/
    /*!
        Execution Graph which stores all nodes and lets them execute in order such that 
        all dependencies (inputs) of any node is computed before it is computed.

        @todo When saving an execution graph, we should make a remapping to linear ids. 

        @date Tue Sep 11 2018
        @author Gabriel Nützi, gnuetzi (at) gmail (døt) com
    */
    /* ---------------------------------------------------------------------------------------*/
    template<typename TConfig>
    class ExecutionTree final
    {
    public:
        EXECGRAPH_DEFINE_CONFIG(TConfig);

        enum NodeClassification : unsigned char
        {
            NormalNode   = 0,
            InputNode    = 1,
            OutputNode   = 2,
            ConstantNode = 3
            //! If you changes this -> adjust m_nNodeClasses!
        };

        using GroupId = unsigned int;

    private:
        static const std::underlying_type_t<NodeClassification> m_nNodeClasses = 4;

    public:
        using NodePointer = std::unique_ptr<NodeBaseType>;
        //! Internal Datastructure to store node related data.
        struct NodeDataBase
        {
            NodeDataBase(NodePointer node, NodeClassification c, bool isAutoGenerated = false)
                : m_node(std::move(node)), m_class(c), m_isAutoGenerated(isAutoGenerated)
            {}

            NodePointer m_node         = nullptr;
            NodeClassification m_class = NodeClassification::NormalNode;
            bool m_isAutoGenerated     = false;
        };

        struct NodeData : NodeDataBase
        {
            template<typename... Args>
            NodeData(Args&&... args)
                : NodeDataBase(std::forward<Args>(args)...)
            {}

            std::unordered_set<GroupId> m_groups;  //!< To which group ids this node belongs.
            IndexType m_priority = 0;              //!< The priority of this node

            void resetTraversalParameters() { m_flags = 0; }
            enum TraversalFlags : int
            {
                Visited,          //!< All visited nodes (globally)
                OnCurrentDFRPath  //!< This mark is set for all nodes on the current depth-first recursion path.
            };
            bool isFlagSet(TraversalFlags position) const { return m_flags & (1 << position); }
            void setFlag(TraversalFlags position) { m_flags |= (1 << position); }
            void unsetFlag(TraversalFlags position) { m_flags &= ~(1 << position); }

        private:
            int m_flags = 0;  //! Some flags for graph traversal
        };

        using ConstantNodeDataStorage = std::unordered_map<NodeId, NodeDataBase>;
        using NodeDataStorage         = std::unordered_map<NodeId, NodeData>;  // Rehashing does not invalidate pointers or references to elements.

        using NodeDataList = std::vector<NodeData*>;
        using NodeDataSet  = std::unordered_set<NodeData*>;
        using NodeDataMap  = std::unordered_map<NodeId, NodeDataBase*>;

        using GroupNodeMap = std::unordered_map<GroupId, NodeDataSet>;

        using PrioritySet        = std::map<IndexType, NodeDataList, std::greater<IndexType>>;
        using GroupExecutionList = std::unordered_map<GroupId, PrioritySet>;

        using LogicNodeDefaultOutputs = LogicNodeDefaultPool<TConfig>;

        struct GraphTypeDescription
        {
            std::unordered_set<std::string> m_nodeTypes;    //!< Type names of the available and creatable nodes on this graph.
            std::unordered_set<std::string> m_socketTypes;  //!< Type names of the available sockets.
        };

    public:
        ExecutionTree()
        {
            addDefaultOutputPool();
        }

        ~ExecutionTree() = default;

        ExecutionTree(ExecutionTree&&) = default;
        ExecutionTree& operator=(ExecutionTree&&) = default;

        //! Set the node class of a specific node id `nodeId`.
        //! Invalidates the execution order.
        void setNodeClass(NodeId nodeId, NodeClassification newType)
        {
            m_executionOrderUpToDate = false;

            auto it = m_nonConstNodes.find(nodeId);
            EXECGRAPH_THROW_IF(it == m_nonConstNodes.end(),
                               "Node with id: '{0}' does not exist in tree!",
                               nodeId);

            NodeClassification& currType = it->second.m_class;
            if(currType == newType)
            {
                return;
            }

            NodeBaseType* node = it->second.m_node.get();

            m_nodeClassifications[currType].erase(node);    // Remove from class.
            currType = newType;                             // Set new classification
            m_nodeClassifications[currType].emplace(node);  // Add to class.
        }

        //! Set the node class of a specific `node`.
        //! Invalidates the execution order.
        void setNodeClass(NodeBaseType& node, NodeClassification newType)
        {
            setNodeClass(node.getId(), newType);
        }

        //! Generate a new unique node id (not yet contained in the graph).
        NodeId generateNodeId()
        {
            EXECGRAPH_ASSERT(m_nextNodeId != std::numeric_limits<NodeId>::max(),
                             "Maximal node count reached! (max() reserved for defaultOutputPool)");
            return m_nextNodeId;
        }
        //! Get a specific node with id `nodeId` if it exists, nullptr otherwise.
        //! This invalidates the execution order, since we cannot guarantee that the caller added other links.
        //! To circumvent that, use the const method.
        NodeBaseType* getNode(NodeId nodeId)
        {
            auto it = m_nodes.find(nodeId);
            if(it == m_nodes.end())
            {
                return nullptr;
            }
            m_executionOrderUpToDate = false;
            return it->second->m_node.get();
        }
        //! Get a specific node with id `nodeId` if it exists, nullptr otherwise.
        //! Does not invalidate execution order.
        const NodeBaseType* getNode(NodeId nodeId) const
        {
            auto* p                  = static_cast<ExecutionTree<Config> const*>(this)->getNode(nodeId);
            m_executionOrderUpToDate = true;
            return p;
        }

        //! Get the pool of default output sockets.
        //! All not connected input sockets will be hooked up to these default output sockets!
        LogicNodeDefaultOutputs& getDefaultOuputPool() { return *m_nodeDefaultOutputPool; }

        //! Get all nodes classified as `type`.
        const NodeDataSet& getNodes(NodeClassification type) const { return m_nodeClassifications[type]; }

        //! Get all nodes in the group with id `groupId`.
        const NodeDataSet& getNodes(GroupId groupId) const
        {
            auto it = m_nodeGroups.find(groupId);
            EXECGRAPH_THROW_IF(it == m_nodeGroups.end(),
                               "Group with id: '{0}' is not part of the tree!",
                               groupId);
            return it->second;
        }

        //! Get all nodes in this graph: all but constant nodes, and only constant nodes.
        std::pair<const NodeDataStorage&,
                  const ConstantNodeDataStorage&>
        getNodes() const
        {
            return {m_nonConstNodes, m_constNodes};
        }

        //! Adds a node to the execution graph and classifies it as `type`
        //! corresponding to group id `groupId` (ignored for constant nodes!).
        NodeBaseType* addNode(NodePointer node,
                              NodeClassification type = NodeClassification::NormalNode,
                              GroupId groupId         = 0)
        {
            EXECGRAPH_THROW_IF(node == nullptr, "Nullptr added!");
            auto id = node->getId();

            EXECGRAPH_THROW_IF(m_nodes.find(id) != m_nodes.end(),
                               "Node id: '{0}' already added in tree!",
                               id);

            if(type != NodeClassification::ConstantNode)
            {
                m_executionOrderUpToDate = false;
            }

            NodeBaseType* pNode = node.get();
            if(type == NodeClassification::ConstantNode)
            {
                // Constant node
                auto p      = m_constNodes.emplace(id, NodeDataBase{std::move(node), type});
                m_nodes[id] = &p.first->second;
            }
            else
            {
                // Any other node
                auto p      = m_nonConstNodes.emplace(id, NodeData{std::move(node), type});
                m_nodes[id] = &p.first->second;
                // Add node to group
                addNodeToGroup(id, groupId);
            }

            // Add to classes
            m_nodeClassifications[type].emplace(pNode);

            m_nextNodeId = std::max(m_nextNodeId, id) + 1;

            return pNode;
        }

        //! Remove an node with id `nodeId` from the graph.
        //! A programming error is fatal ==> UB.
        NodePointer removeNode(NodeId nodeId)
        {
            auto nodeIt = m_nodes.find(nodeId);
            if(nodeIt == m_nodes.end())
            {
                return nullptr;
            }

            NodeDataBase* nodeDataBase = nodeIt->second;

            // Erase from the classifications.
            EXECGRAPH_VERIFY(m_nodeClassifications[nodeDataBase->m_class].erase(nodeDataBase->m_node.get()),
                             "Programming error!");

            // Move the node out!
            NodePointer node = std::move(nodeDataBase->m_node);

            if(nodeDataBase->m_class == NodeClassification::ConstantNode)
            {
                // Remove from constant nodes.
                EXECGRAPH_VERIFY(m_constNodes.erase(nodeId), "Programming error!");
            }
            else
            {
                auto* nodeData = static_cast<NodeData*>(nodeDataBase);

                // Remove from groups.
                for(auto groupId : nodeData->m_groups)
                {
                    auto groupIt = m_nodeGroups.find(groupId);
                    EXECGRAPH_ASSERT(groupIt != m_nodeGroups.end(), "Programming error!");
                    EXECGRAPH_VERIFY(groupIt->second.erase(nodeData), "Programming error!");
                }

                // Remove from non-constant nodes.
                EXECGRAPH_VERIFY(m_nonConstNodes.erase(nodeId), "Programming error!");
            }
            // Erase from nodes.
            m_nodes.erase(nodeIt);

            // Decrement next current node id.
            if(nodeId + 1 == m_nextNodeId)
            {
                --m_nextNodeId;
            }

            // Execution order is not up-to-date.
            m_executionOrderUpToDate = false;

            return std::move(node);
        }

        //! Add the node with id `nodeId` to the group with id `groupId`.
        void addNodeToGroup(NodeId nodeId, GroupId groupId)
        {
            auto it = m_nonConstNodes.find(nodeId);
            EXECGRAPH_THROW_IF(it == m_nonConstNodes.end(),
                               "Node with id: '{0}' does not exist in tree!",
                               nodeId);
            // Add node to the group
            it->second.m_groups.emplace(groupId);
            m_nodeGroups[groupId].emplace(&it->second);

            m_executionOrderUpToDate = false;
        }

        //! Constructs a Get-Link to get the data from output socket at index `outS`
        //! of node `outN` at the input socket at index `inS` of node `inN`.
        void setGetLink(NodeId outN, SocketIndex outS, NodeId inN, SocketIndex inS)
        {
            auto outNit = m_nodes.find(outN);
            auto inNit  = m_nodes.find(inN);
            EXECGRAPH_THROW_IF(outNit == m_nodes.end() || inNit == m_nodes.end(),
                               "Node with id: '{0}' or '{1}' does not exist!",
                               outN,
                               inN)
            NodeBaseType::setGetLink(*outNit->second->m_node, outS, *inNit->second->m_node, inS);
            m_executionOrderUpToDate = false;
        }

        //! Removes a Get-Link to get the data from output socket at index `outS`
        //! of node `outN` at the input socket at index `inS` of node `node`.
        //! If `outN` and `outS` are set, the function throws if the get link does not match!
        void removeGetLink(NodeId inN,
                           SocketIndex inS,
                           const NodeId* outN      = nullptr,
                           const SocketIndex* outS = nullptr)
        {
            auto nodeIt = m_nodes.find(inN);
            EXECGRAPH_THROW_IF(nodeIt == m_nodes.end(),
                               "Node with id: '{0}' does not exist!",
                               inN);

            auto& node = *(nodeIt->second->m_node);
            // There is only one get link! Check
            if(!outN && !outS && node.hasISocket(inS))
            {
                auto* outSocket = node.getISocket(inS).followGetLink();
                EXECGRAPH_THROW_TYPE_IF(!outSocket || (outSocket->getIndex() != *outS ||
                                                       outSocket->getParent().getId() != *outN),
                                        NodeConnectionException,
                                        "The output socket '{0}' of node '{1}' of the get link does "
                                        "not correspond to the one you want to remove "
                                        "(node id: '{2}', output socket: '{3}')",
                                        outSocket->getIndex(),
                                        outSocket->getParent().getId(),
                                        *outN,
                                        *outS);
            }

            node.removeGetLink(inS);

            m_executionOrderUpToDate = false;
        }

        //! Constructs a Write-Link to write the data of output socket at index
        //! `outS` of node `outN` to the input socket at index `inS` of node
        //! `inN`.
        void addWriteLink(NodeId outN, SocketIndex outS, NodeId inN, SocketIndex inS)
        {
            auto outNit = m_nodes.find(outN);
            auto inNit  = m_nodes.find(inN);
            if(outNit == m_nodes.end() || inNit == m_nodes.end())
            {
                EXECGRAPH_THROW("Node with id: '{0}' or '{1}' does not exist!", outN, inN);
            }
            NodeBaseType::addWriteLink(*outNit->second->m_node, outS, *inNit->second->m_node, inS);
            m_executionOrderUpToDate = false;
        }

        //! Remove a Write-Link to write the data of output socket at index
        //! `outS` of node `outN` to the input socket at index `inS` of node
        //! `inN`.
        void removeWriteLink(NodeId outN, SocketIndex outS, NodeId inN, SocketIndex inS)
        {
            auto outNit = m_nodes.find(outN);
            auto inNit  = m_nodes.find(inN);
            if(outNit == m_nodes.end() || inNit == m_nodes.end())
            {
                EXECGRAPH_THROW("Node with id: '{0}' or '{1}' does not exist!", outN, inN);
            }
            NodeBaseType::removeWriteLink(*outNit->second->m_node, outS, *inNit->second->m_node, inS);
            m_executionOrderUpToDate = false;
        }

        //! Reset all nodes in group with id: `groupId`.
        void runReset(unsigned int groupId)
        {
            EXECGRAPH_THROW_IF(!m_executionOrderUpToDate,
                               "ExecutionTree's execution order is not up to date!");
            // Execute in determined order!
            auto it = m_groupExecList.find(groupId);
            EXECGRAPH_THROW_IF(it == m_groupExecList.end(),
                               "ExecutionTree does not contain a group with id: '{0}'",
                               groupId);
            executePrioritySet(it->second, [](NodeBaseType& node) { node.reset(); });
        }

        //! Reset the whole graph.
        void runReset()
        {
            executePrioritySet(m_execList, [](NodeBaseType& node) { node.reset(); });
        }

        //! Execute all nodes in group with id: `groupId` in their determined order.
        void runExecute(unsigned int groupId)
        {
            EXECGRAPH_THROW_IF(!m_executionOrderUpToDate,
                               "ExecutionTree's execution order is not up to date!");
            // Execute in determined order!
            auto it = m_groupExecList.find(groupId);
            EXECGRAPH_THROW_IF(it == m_groupExecList.end(),
                               "ExecutionTree does not contain a group with id: '{0}'",
                               groupId);
            executePrioritySet(it->second, [](NodeBaseType& node) { node.compute(); });
        }

        //! Execute the whole graph.
        void runExecute()
        {
            EXECGRAPH_THROW_IF(!m_executionOrderUpToDate,
                               "ExecutionTree's execution order is not up to date!")

            executePrioritySet(m_execList, [](NodeBaseType& node) { node.compute(); });
        }

        //! Setups the execution tree by building its execution order.
        void setup(bool connectAllDanglingInputs = true, bool checkResults = false)
        {
            // Allways check results in Debug mode.
            EXECGRAPH_DEBUG_ONLY(checkResults = true;)

            if(m_nodeClassifications[NodeClassification::OutputNode].size() == 0)
            {
                EXECGRAPH_THROW("No output nodes specified!");
            }

            // Solve execution order globally over all groups!
            // Each group has its own execution order based on the the global computed one!
            ExecutionOrderSolver solver(m_nonConstNodes,
                                        m_constNodes,
                                        (connectAllDanglingInputs) ? m_nodeDefaultOutputPool : nullptr);
            solver.solve(m_execList, m_groupExecList);

            // Check if each output node reaches at least one input, if not print warning!
            ReachNodeCheck c;
            for(auto* outNode : m_nodeClassifications[NodeClassification::OutputNode])
            {
                bool outputReachedInput = false;

                for(auto* inNode : m_nodeClassifications[NodeClassification::InputNode])
                {
                    if(c.check(outNode, inNode))
                    {
                        outputReachedInput = true;
                        break;
                    }
                }
                EXECGRAPH_WARN(outputReachedInput,
                               "Output node id: '{0}' did not reach any input!",
                               outNode->getId());
            }

            m_executionOrderUpToDate = true;
        }

        //! Get execution order information.
        std::string getExecutionOrderInfo(std::string suffix = "\t\t")
        {
            // Print execution order
            std::stringstream s;
            std::string fmtH = "  %-6s  | %-8s   |  %-20s\n";
            std::string fmt  = "  %-6i  | %-8i   |  %-20s\n";
            for(auto& g : m_groupExecList)
            {
                s << "Execution order for group id: " << g.first << std::endl;
                s << suffix << fmt::printf(fmtH, "NodeId", "Priority", "NodeType") << std::endl;
                s << suffix << fmt::printf(fmtH, "------", "--------", "--------") << std::endl;
                for(auto& p : g.second)
                {
                    for(NodeData* nodeData : p.second)
                    {
                        auto* n = nodeData->m_node.get();
                        s << suffix
                          << fmt::printf(fmt, n->getId(), nodeData->m_priority, rttr::type::get(*n).get_name())
                          << std::endl;
                    }
                }
                s << suffix << fmt::printf(fmtH, "---------------", "------", "--------", "--------") << std::endl;
            }
            return s.str();
        }

    protected:
        //! Add a default pool.
        void addDefaultOutputPool()
        {
            auto id = std::numeric_limits<NodeId>::max();
            // Make a default pool of output sockets.
            auto p                  = std::make_unique<LogicNodeDefaultOutputs>(id);
            m_nodeDefaultOutputPool = p.get();
            addNode(std::move(p), NodeClassification::ConstantNode);
            auto it = m_constNodes.find(id);
            EXECGRAPH_THROW_IF(it == m_constNodes.end(), "Default pool not added!");
            it->second.m_isAutoGenerated = true;
        }

        //! Execute all nodes in PrioritySet.
        template<typename Functor>
        inline void executePrioritySet(PrioritySet& prioritySet, Functor&& func)
        {
            for(auto& p : prioritySet)
            {
                // Execute all nodes with this priority
                for(NodeData* nodeData : p.second)
                {
                    func(*nodeData->m_node);
                }
            }
        }

        class ExecutionSolverBase
        {
        public:
            ExecutionSolverBase(ConstantNodeDataStorage& constantNodes,
                                LogicNodeDefaultOutputs* defaultOutputSockets = nullptr)
                : m_defaultOutputSockets(defaultOutputSockets), m_constNodes(constantNodes) {}

            //! Connects all dangling input sockets to the default output socket.
            void connectAllDanglingInputs(NodeData& nodeData)
            {
                // All input sockets need to be connected!
                for(SocketInputBasePointer& inSocket : nodeData.m_node->getInputs())
                {
                    // Socket is dangling!
                    if(inSocket->getConnectionCount() == 0)
                    {
                        EXECGRAPH_THROW_TYPE_IF(m_defaultOutputSockets == nullptr,
                                                NodeConnectionException,
                                                "Input socket index: '{0}' of node: '{1}' is dangling and cannot be connected to default output, since it is not set!",
                                                inSocket->getIndex(),
                                                nodeData.m_node->getId());
                        m_defaultOutputSockets->connect(*inSocket);
                    }
                }
            }

            void checkResults(const NodeDataStorage& nodes)
            {
                auto check = [&](auto* socket, const NodeData& nodeDataWithLowerPrio) {
                    // Get NodeData of parentNode
                    auto& parentNode = socket->getParent();

                    // Check first if it is a constant node.
                    auto itConstant = m_constNodes.find(parentNode.getId());
                    if(itConstant != m_constNodes.end())
                    {
                        // nothing to check for constant nodes
                        return;
                    }

                    auto itParent = nodes.find(parentNode.getId());
                    EXECGRAPH_THROW_IF(itParent == nodes.end(),
                                       "Node with id: '{0}' has not been added to the execution tree!",
                                       parentNode.getId());
                    const NodeData& parentNodeData = itParent->second;

                    EXECGRAPH_THROW_IF(parentNodeData.m_priority <= nodeDataWithLowerPrio.m_priority,
                                       "Parent node id: '{0}' [prio: '{1}' ]"
                                       "has not a higher priority as node id: '{2}' "
                                       "which is wrong!",
                                       parentNodeData.m_node->getId(),
                                       parentNodeData.m_priority,
                                       nodeDataWithLowerPrio.m_node->getId());
                };

                for(auto& pair : nodes)
                {
                    const NodeData& nodeData = pair.second;
                    // Follow all links
                    auto& inSockets = nodeData.m_node->getInputs();
                    for(auto& socket : inSockets)
                    {
                        // Try adding the get link to the stack
                        if(socket->hasGetLink())
                        {
                            check(socket->followGetLink(), nodeData);
                        }
                        // Try adding all writing links to the stack
                        for(auto* outputSocket : socket->getWritingSockets())
                        {
                            check(outputSocket, nodeData);
                        }
                    }
                }
            }

        protected:
            LogicNodeDefaultOutputs* m_defaultOutputSockets;  //!< Default output sockets which are used for all dangling input sockets.
            ConstantNodeDataStorage& m_constNodes;            //!< Constant nodes which do not need evaluation.
        };

        //! The solver for computing the execution order.
        class ExecutionOrderSolver : public ExecutionSolverBase
        {
        public:
            ExecutionOrderSolver(NodeDataStorage& nodes,
                                 ConstantNodeDataStorage& constantNodes,
                                 LogicNodeDefaultOutputs* defaultOutputSockets = nullptr)
                : ExecutionSolverBase(constantNodes, defaultOutputSockets), m_nonConstNodes(nodes)
            {
            }

            /*! Solves the execution order for an input node set `nodes` and
            outputs the ordered execution list `orderedNodes`.

            This algorithm is based on https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search.
            We visit each node once during this algorithm.
            From each node `a` in `nodes` we start a depth-first recursion (DFR), basically exploring the whole subtree `S`
            of each node `a`. While exploring, we set the NodeData::m_priority of each node in the subtree with root = `a`.

            For each DFR, we trace the current path explored by marking each node by the flag NodeData::OnCurrentDFRPath.
            This allows to detect cycles.

            When a node is visited its NodeData::Visited flag gets set.
            A DFR starts only from a node which has NodeData::Visited == false.
            During a DFR, a new child node is explored (added to the m_dfrStack) only if
            its priority is not greater than the parent.
            When the child node is added the flag NodeData::Visited is unset!
        */
            void solve(PrioritySet& prioritiesGlobal,
                       GroupExecutionList& prioritiesPerGroup,
                       bool checkResults = true)
            {
                prioritiesPerGroup.clear();
                prioritiesGlobal.clear();

                //! @todo Find a good stack size depending on tree height.
                m_dfrStack.reserve(10);

                // Remove all nodes up the stack which are visited
                // while doing so unmark the nodes.
                auto doBackTracking = [&]() {
                    auto itStart = m_dfrStack.rbegin();
                    auto itEnd   = m_dfrStack.rend();
                    auto it      = itStart;
                    while(it != itEnd)
                    {
                        if(!(*it)->isFlagSet(NodeData::Visited))
                        {
                            // Not visited, backtracking finished!
                            // Remove the range [itStart,itLast) from the stack
                            break;
                        }
                        (*it)->unsetFlag(NodeData::OnCurrentDFRPath);  // Remove Mark
                        ++it;
                    }
                    EXECGRAPH_ASSERT(std::distance(itStart, it) <= static_cast<typename decltype(m_dfrStack)::difference_type>(m_dfrStack.size()),
                                     "Removing: '{0}' from '{1}'",
                                     std::distance(itStart, it),
                                     m_dfrStack.size());
                    // Convert backward iterator to forward
                    m_dfrStack.erase(it.base(), itStart.base());
                };

                // Loop over all nodes and start a depth-first-search
                for(auto& keyValue : m_nonConstNodes)
                {
                    NodeData* nodeData = &keyValue.second;
                    // If the node is visited we know that the node was contained in a depth-first recursion
                    // we know that the prioriteis below it are correct, so skip this one
                    if(nodeData->isFlagSet(NodeData::Visited))
                    {
                        EXECGRAPH_EXECTREE_SOLVER_LOG("DFS Start: Node id: '{0}'  already visited -> skip it.",
                                                      nodeData->m_node->getId());
                        continue;
                    }

                    EXECGRAPH_EXECTREE_SOLVER_LOG("DFS Start: Node id: '{0}'",
                                                  nodeData->m_node->getId());

                    // Start a depth-first recursion from this node (exploring its subtree)
                    m_dfrStack.clear();
                    // Insert root node
                    m_dfrStack.push_back(nodeData);

                    // Loop variables
                    NodeData* currentNode;
                    std::size_t currentSize;

                    while(!m_dfrStack.empty())
                    {
                        EXECGRAPH_EXECTREE_SOLVER_LOG("DFS Stack: {0}", getStackInfo());

                        currentNode = m_dfrStack.back();
                        currentSize = m_dfrStack.size();

                        // We are doing depth first search and try to visit a node which is already on the
                        // current DFR path.
                        EXECGRAPH_THROW_TYPE_IF(currentNode->isFlagSet(NodeData::OnCurrentDFRPath),
                                                ExecutionGraphCycleException,
                                                "Your execution logic graph contains a cycle! "
                                                "Current traversal stack: '{0}'");

                        visit(*currentNode);  // Visits neighbors and add them to m_dfrStack

                        // If no nodes have been added, down traversal is finished, we do now backtracking
                        if(currentSize == m_dfrStack.size())
                        {
                            doBackTracking();  // Removing all visited nodes up the stack
                        }
                    }
                }

                // Loop over all nodes and make priority sets:
                for(auto& keyValue : m_nonConstNodes)
                {
                    NodeData* nodeData = &keyValue.second;

                    nodeData->resetTraversalParameters();

                    prioritiesGlobal[nodeData->m_priority].emplace_back(nodeData);
                    // Put the nodes into PrioritySets for each Group
                    for(auto& groupId : nodeData->m_groups)
                    {
                        prioritiesPerGroup[groupId][nodeData->m_priority].emplace_back(nodeData);
                    }

                    // Connect all dangling input sockets.
                    ExecutionSolverBase::connectAllDanglingInputs(*nodeData);
                }

                // Check execution order by checking all inputs of all nodes
                if(checkResults)
                {
                    this->checkResults(m_nonConstNodes);
                }
            }

        private:
            //! Return current DFS stack, but only nodes which are on the current DFR path.
            std::string getTraversalInfo()
            {
                std::stringstream ss;
                auto it = m_dfrStack.begin();
                if(it != m_dfrStack.end() && (*it)->isFlagSet(NodeData::OnCurrentDFRPath))
                {
                    ss << (*(it++))->m_node->getId();
                }
                for(; it != m_dfrStack.end(); ++it)
                {
                    if((*it)->isFlagSet(NodeData::OnCurrentDFRPath))
                    {
                        ss << " ---> " << (*it)->m_node->getId();
                    }
                }
                return ss.str();
            }

            //! Return current DFS stack, visited nodes are marked with "*".
            std::string getStackInfo()
            {
                std::stringstream ss;
                ss << "[ ";
                for(auto* nodeData : m_dfrStack)
                {
                    ss << nodeData->m_node->getId() << (nodeData->isFlagSet(NodeData::Visited) ? "*" : " ") << ", ";
                }
                ss << " ]";
                return ss.str();
            }

            /**
             * This is the visit function during Depth-First-Search,
             * It adds nodes to the dfsStack if the priority is lower then the one of `nodeData`.
             */
            void visit(NodeData& nodeData)
            {
                EXECGRAPH_EXECTREE_SOLVER_LOG("visit: '{0}'", nodeData.m_node->getId());

                auto addParentsToStack = [&](auto* socket) {
                    // Get NodeData of parentNode
                    auto& parentNode = socket->getParent();
                    auto itParent    = m_nonConstNodes.find(parentNode.getId());
                    if(itParent == m_nonConstNodes.end())
                    {
                        EXECGRAPH_ASSERT(this->m_constNodes.find(parentNode.getId()) != this->m_constNodes.end(),
                                         "Parent node with id: '{0}' is not a constant node!",
                                         parentNode.getId());
                        return;
                    }

                    NodeData* parentNodeData = &itParent->second;

                    if(parentNodeData->m_priority <= nodeData.m_priority)
                    {
                        // Parent needs a other priority (because its computation becomes before nodeData)
                        parentNodeData->m_priority = nodeData.m_priority + 1;
                        parentNodeData->unsetFlag(NodeData::Visited);
                        m_dfrStack.push_back(parentNodeData);  // Add to stack and explore its subgraph
                    }
                };

                // Follow all links
                auto& inSockets = nodeData.m_node->getInputs();
                for(auto& socket : inSockets)
                {
                    // Try adding the get link to the stack
                    if(socket->hasGetLink())
                    {
                        addParentsToStack(socket->followGetLink());
                    }
                    // Try adding all writing links to the stack
                    for(auto* outputSocket : socket->getWritingSockets())
                    {
                        addParentsToStack(outputSocket);
                    }
                }

                // Mark this node as on the current depth-first recursion path
                nodeData.setFlag(NodeData::OnCurrentDFRPath);

                // Mark this node as visited
                nodeData.setFlag(NodeData::Visited);
            }

            bool m_inputReachable     = false;
            NodeBaseType* m_reachNode = nullptr;
            NodeDataStorage& m_nonConstNodes;  //!< All NodeDatas of the execution tree.

            std::vector<NodeData*> m_dfrStack;  //!< Depth-First-Search Stack
        };

        //! First computes a topological order and then assigns priorities.
        class ExecutionOrderSolver2 : public ExecutionSolverBase
        {
        public:
            ExecutionOrderSolver2(NodeDataStorage& nodes,
                                  ConstantNodeDataStorage& constantNodes,
                                  LogicNodeDefaultOutputs* defaultOutputSockets = nullptr)
                : ExecutionSolverBase(constantNodes, defaultOutputSockets), m_nonConstNodes(nodes)
            {
            }

            void solve(PrioritySet& prioritiesGlobal,
                       GroupExecutionList& prioritiesPerGroup,
                       bool checkResults = true)
            {
                prioritiesPerGroup.clear();
                prioritiesGlobal.clear();

                //! @todo Find a good stack size depending on tree height.
                m_dfrStack.reserve(10);
                NodeDataList topoSortList;
                topoSortList.reserve(10);

                // Remove all nodes up the stack which are visited
                // while doing so unmark the nodes.
                auto doBackTracking = [&]() {
                    auto itStart = m_dfrStack.rbegin();
                    auto itEnd   = m_dfrStack.rend();
                    auto it      = itStart;
                    while(it != itEnd)
                    {
                        if(!(*it)->isFlagSet(NodeData::Visited))
                        {
                            // Not visited, backtracking finished!
                            // Remove the range [itStart,itLast) from the stack
                            break;
                        }

                        // If the node is marked unmark and add it to the topoSortList
                        if((*it)->isFlagSet(NodeData::OnCurrentDFRPath))
                        {
                            topoSortList.push_back(*it);
                            (*it)->unsetFlag(NodeData::OnCurrentDFRPath);
                        }

                        // Goto next node
                        ++it;
                    }
                    EXECGRAPH_ASSERT(std::distance(itStart, it) <= m_dfrStack.size(),
                                     "Removing: '{0}' from '{1}'",
                                     std::distance(itStart, it),
                                     m_dfrStack.size());
                    // Convert backward iterator to forward
                    m_dfrStack.erase(it.base(), itStart.base());
                };

                // Loop over all nodes and start a depth-first-search
                for(auto& keyValue : m_nonConstNodes)
                {
                    NodeData* nodeData = &keyValue.second;

                    EXECGRAPH_EXECTREE_SOLVER_LOG("DFS Start: Node id: '{0}'", nodeData->m_node->getId());
                    // Skip visited nodes.
                    if(nodeData->isFlagSet(NodeData::Visited))
                    {
                        continue;
                    }

                    // Start a depth-first recursion from this node (exploring this subtree)
                    m_dfrStack.clear();
                    // Insert root node
                    m_dfrStack.push_back(nodeData);

                    NodeData* currentNode;
                    std::size_t currentSize;

                    while(!m_dfrStack.empty())
                    {
                        EXECGRAPH_EXECTREE_SOLVER_LOG("DFS Stack: {0}", getStackInfo());

                        currentNode = m_dfrStack.back();

                        // We are doing depth first search and found another already visited node
                        // meaning we have a cycle.
                        EXECGRAPH_THROW_TYPE_IF(currentNode->isFlagSet(NodeData::OnCurrentDFRPath),
                                                ExecutionGraphCycleException,
                                                "Your execution logic graph contains a cycle! "
                                                "Current traversal stack: '{0}'",
                                                getTraversalInfo());

                        currentNode->setFlag(NodeData::OnCurrentDFRPath);
                        currentSize = m_dfrStack.size();
                        visit(*currentNode);  // Visits neighbors and add them to m_dfrStack

                        // If no nodes have been added, down traversal is finished, we do now backtracking
                        if(currentSize == m_dfrStack.size())
                        {
                            doBackTracking();  // Removing all visited nodes up the stack
                        }
                    }
                }

                // Topological sort finished
                // Traverse the sorted list from the back and assign the priorities

                auto rEndIt = topoSortList.rend();
                for(auto nodeDataIt = topoSortList.rbegin(); nodeDataIt != rEndIt; ++nodeDataIt)
                {
                    NodeData* nodeData = *nodeDataIt;
                    assignPrioritiesToChilds(*nodeData);
                    ExecutionSolverBase::connectAllDanglingInputs(*nodeData);
                }

                for(NodeData* nodeData : topoSortList)
                {
                    prioritiesGlobal[nodeData->m_priority].emplace_back(nodeData);
                    // Put the nodes into PrioritySets for each Group
                    for(auto& groupId : nodeData->m_groups)
                    {
                        prioritiesPerGroup[groupId][nodeData->m_priority].emplace_back(nodeData);
                    }
                }

                // Check execution order by checking all inputs of all nodes
                if(checkResults)
                {
                    this->checkResults(m_nonConstNodes);
                }
            }

        private:
            //! Return current DFS stack, but only nodes which are on the current DFR path.
            std::string getTraversalInfo()
            {
                std::stringstream ss;
                auto it = m_dfrStack.begin();
                if(it != m_dfrStack.end() && (*it)->isFlagSet(NodeData::OnCurrentDFRPath))
                {
                    ss << (*(it++))->m_node->getId();
                }
                for(; it != m_dfrStack.end(); ++it)
                {
                    if((*it)->isFlagSet(NodeData::OnCurrentDFRPath))
                    {
                        ss << " ---> " << (*it)->m_node->getId();
                    }
                }
                return ss.str();
            }

            //! Return current DFS stack, visited nodes are marked with "*".
            std::string getStackInfo()
            {
                std::stringstream ss;
                ss << "[ ";
                for(auto* nodeData : m_dfrStack)
                {
                    ss << nodeData->m_node->getId() << (nodeData->isFlagSet(NodeData::Visited) ? "*" : " ") << ", ";
                }
                ss << " ]";
                return ss.str();
            }

            /**
             * This is the visit function during Depth-First-Search,
             * It adds nodes to the dfsStack if the priority is lower then the one of `nodeData`.
             */
            void visit(NodeData& nodeData)
            {
                EXECGRAPH_EXECTREE_SOLVER_LOG("visit: '{0}'", nodeData.m_node->getId());

                auto addParentsToStack = [&](auto* socket) {
                    // Get NodeData of parentNode
                    auto& parentNode = socket->getParent();
                    auto itParent    = m_nonConstNodes.find(parentNode.getId());
                    if(itParent == m_nonConstNodes.end())
                    {
                        EXECGRAPH_ASSERT(this->m_constNodes.find(parentNode.getId()) != this->m_constNodes.end(),
                                         "Parent node with id: '{0}' is not a constant node!",
                                         parentNode.getId());
                        return;
                    }
                    NodeData* parentNodeData = &itParent->second;

                    if(!parentNodeData->isFlagSet(NodeData::Visited))
                    {
                        m_dfrStack.push_back(parentNodeData);  // Add to stack and explore its subgraph
                    }
                };

                // Follow all links
                auto& inSockets = nodeData.m_node->getInputs();
                for(auto& socket : inSockets)
                {
                    // Try adding the get link to the stack
                    if(socket->hasGetLink())
                    {
                        addParentsToStack(socket->followGetLink());
                    }
                    // Try adding all writing links to the stack
                    for(auto* outputSocket : socket->getWritingSockets())
                    {
                        addParentsToStack(outputSocket);
                    }
                }

                // Mark this node as visited
                nodeData.setFlag(NodeData::Visited);
            }

            void assignPrioritiesToChilds(NodeData& nodeData)
            {
                auto assignToChild = [&](auto* socket) {
                    // Get NodeData of parentNode
                    auto& parentNode = socket->getParent();
                    auto itParent    = m_nonConstNodes.find(parentNode.getId());
                    EXECGRAPH_THROW_IF(itParent == m_nonConstNodes.end(),
                                       "Node with id: '{0}' has not been added to the execution tree!",
                                       parentNode.getId());
                    NodeData* parentNodeData = &itParent->second;

                    if(parentNodeData->m_priority <= nodeData.m_priority)
                    {
                        parentNodeData->m_priority = nodeData.m_priority + 1;
                    }
                };

                // Follow all links
                auto& inSockets = nodeData.m_node->getInputs();
                for(auto& socket : inSockets)
                {
                    // Try adding the get link to the stack
                    if(socket->hasGetLink())
                    {
                        assignToChild(socket->followGetLink());
                    }
                    // Try adding all writing links to the stack
                    for(auto* outputSocket : socket->getWritingSockets())
                    {
                        assignToChild(outputSocket);
                    }
                }
            }

            bool m_inputReachable     = false;
            NodeBaseType* m_reachNode = nullptr;
            NodeDataStorage& m_nonConstNodes;   //!< All node datas of of non-constant nodes.
            std::vector<NodeData*> m_dfrStack;  //!< Depth-First-Search Stack
        };

        //! Only for directed graphs, does not detect cycles -> endless loop!
        class ReachNodeCheck
        {
        public:
            // From end to start node
            bool check(NodeBaseType* endNode, NodeBaseType* startNode)
            {
                if(endNode == startNode)
                {
                    return true;
                }

                m_start   = startNode;
                m_reached = false;

                std::deque<NodeBaseType*> currentNodes;  // Breath first search
                currentNodes.push_back(endNode);

                // visit current front node, as long as currentNode list is not empty or
                // start has not yet been found!
                while(currentNodes.size() != 0 && m_reached == false)
                {
                    visit(currentNodes.front(), currentNodes);
                    currentNodes.pop_front();
                }

                return m_reached;
            }

        private:
            /**
             * Breath first search:
             */
            void visit(NodeBaseType* node, std::deque<NodeBaseType*>& queu)
            {
                // visit all input sockets and their node!
                auto& inSockets = node->getInputs();
                for(auto& socket : inSockets)
                {
                    if(socket->hasGetLink())
                    {
                        auto* outputSocket = socket->followGetLink();
                        auto& parentNode   = outputSocket->getParent();
                        // If we reached the start node, return!
                        if(m_start == &parentNode)
                        {
                            m_reached = true;
                            return;
                        }

                        queu.push_back(&parentNode);
                    }
                }
            }

            bool m_reached        = false;
            NodeBaseType* m_start = nullptr;
        };

        std::set<NodeBaseType*> m_nodeClassifications[m_nNodeClasses];  //!< The classification set for each node class.

        NodeDataMap m_nodes;                   //!< All nodes in the execution tree
        NodeDataStorage m_nonConstNodes;       //!< All nodes in the execution tree (main storage) except for constant nodes.
        ConstantNodeDataStorage m_constNodes;  //!< All constant nodes (main storage) which do not need evaluation and are also not part of the execution order.

        GroupNodeMap m_nodeGroups;           //!< The map of nodes in each group.
        PrioritySet m_execList;              //!< The global execution order.
        GroupExecutionList m_groupExecList;  //!< The execution order for each group.

        bool m_executionOrderUpToDate = false;  //!< Dirty flag which denotes that the execution order is not up to date!

        LogicNodeDefaultOutputs* m_nodeDefaultOutputPool;  //!< Default Pool with output sockets, to which all not connected input sockets are connected!

        NodeId m_nextNodeId = 0;  //!< Next node id currently available.
    };
}  // namespace executionGraph

#undef EXECGRAPH_EXECTREE_SOLVER_LOG
#endif  // ExecutionTree_hpp
